### Получение первичной информации по базе данных

Выполните следующие шаги, чтобы немного узнать о базе данных:

1. Используйте этот запрос, чтобы получить список 20 самых больших таблиц в текущей базе данных:

        SELECT oid::REGCLASS::TEXT AS table_name, pg_size_pretty(pg_total_relation_size(oid)) AS total_size FROM pg_class WHERE relkind = 'r' 
        AND relpages > 0 ORDER BY pg_total_relation_size(oid) DESC LIMIT 20;

2. Используйте этот запрос, чтобы получить список 20 самых больших индексов в текущей базе данных и их родительских таблицах:

        SELECT indexrelid::REGCLASS::TEXT AS index_name, indrelid::REGCLASS::TEXT AS table_name, pg_size_pretty(pg_relation_size(indexrelid)) 
        AS total_size FROM pg_index ORDER BY pg_relation_size(indexrelid) DESC LIMIT 20;

3. Используйте этот запрос, чтобы найти 20 самых активных таблиц, определив те из них, которые получают больше всего inserts, updates, or deletes:

        SELECT relid::REGCLASS AS table_name, 
                        n_tup_ins AS inserts, 
                        n_tup_upd + n_tup_hot_upd AS updates, 
                        n_tup_del AS deletes 
                  FROM pg_stat_user_tables 
                 ORDER BY (n_tup_ins + n_tup_upd + 
                        n_tup_hot_upd + n_tup_del) DESC 
                 LIMIT 20;

4. Используйте этот вариант, чтобы получить лучшие таблицы с активностью выборки, проверив сканирование индекса и таблицы:
(Use this variant to obtain top tables with fetch activity by checking index and table scans:)

                SELECT relid::REGCLASS AS table_name, 
                               coalesce(seq_scan, 0) AS sequential_scans, 
                               coalesce(idx_scan, 0) AS index_scans, 
                               coalesce(seq_tup_read, 0) AS table_matches, 
                               coalesce(idx_tup_fetch, 0) AS index_matches 
                          FROM pg_stat_user_tables 
                         ORDER BY (coalesce(seq_scan, 0) +  
                               coalesce(idx_scan, 0)) DESC, 
                               (coalesce(seq_tup_read, 0) + 
                               coalesce(idx_tup_fetch, 0)) DESC 
                         LIMIT 20;

5. Используйте этот запрос для первых 20 индексов с активностью чтения в текущей базе данных:
(Use this query for the top 20 indexes with read activity in the current database:)

        SELECT indexrelid::REGCLASS AS index_name, 
                       coalesce(idx_scan, 0) AS index_scans, 
                       coalesce(idx_tup_read, 0) AS rows_read, 
                       coalesce(idx_tup_fetch, 0) AS rows_fetched 
                  FROM pg_stat_user_indexes 
                 ORDER BY (coalesce(idx_scan, 0) +  
                        coalesce(idx_tup_read, 0)) DESC 
                 LIMIT 20;

#### Как они работают
каждый из этих запросов предлагает отдельную информацию о базе данных. Простое выполнение их в вакууме дает очень мало информации. Мы должны смотреть на результаты каждого, чтобы узнать что-нибудь. Кроме того, все представления системного каталога возвращают статистику только для текущей базы данных, к которой мы подключены.

Если экземпляр PostgreSQL имеет десятки баз данных, а мы подключены только к одной, статистика будет применяться только к этой конкретной базе данных. Чтобы получить статистику по каждой базе данных в экземпляре, нам нужно будет подключиться к каждой из них и собрать информацию отдельно.

Первый запрос возвращает 20 самых больших таблиц в базе данных, включая связанные индексы и данные метода хранения атрибутов большого размера (TOAST). Таким образом, если таблица имеет большое количество слишком длинных строк данных или несколько индексов, мы все равно получим ее истинный размер по отношению ко всем другим таблицам. 

Следующий запрос возвращает 20 самых больших индексов в базе данных. Хотя весьма вероятно, что они будут связаны с самыми большими таблицами, это не обязательно так. Действительно, здесь также будут перечислены большие составные индексы, функциональные индексы или раздутые индексы. Индексы (не являющиеся первичными ключами), представленные в этом списке, являются хорошими кандидатами на оптимизацию либо путем замены их частичными индексами, либо более эффективной версией.

После размера мы переходим к активности в таблице. 

Третий запрос возвращает 20 наиболее активных таблиц на основе операций записи. Во многих случаях это позволяет сразу определить таблицы с высокой текучестью (turnover), которые часто вызывают автоочистку или автоматический анализ и могут потребовать ручной настройки. Часто здесь появляются таблицы сеансов пользователей из-за неэффективного хранения данных веб-сеансов; идентификация предоставляет боеприпасы для пересмотра процесса (identification provides ammunition for process revision). Чрезмерно активные таблицы являются узким местом и должны быть сведены к минимуму, если это возможно.

Затем мы можем захотеть узнать информацию о выборе таблицы (table select information). Четвертый запрос несколько грубый, но цель состоит в том, чтобы вернуть 20 таблиц, которые чаще всего считываются пользовательскими сеансами. Опять же, он, скорее всего, выявит таблицы с чрезвычайно завышенной активностью чтения по сравнению со средним значением в базе данных. Эти случаи часто можно уменьшить за счет улучшения кэширования данных внешнего интерфейса, и их идентификация — первый шаг на этом пути.

Наконец, мы можем увидеть 20 лучших индексов, использующих активность чтения. Это может дополнительно изолировать потенциальные индексы, которые следует отслеживать. Если мы инвертируем сортировку этого запроса, мы также можем определить индексы, которые вообще не дают много совпадений и просто тратят место впустую.
